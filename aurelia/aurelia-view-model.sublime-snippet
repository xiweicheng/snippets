<snippet>
	<content><![CDATA[
import { bindable, inject } from 'aurelia-framework';
import { EventAggregator } from 'aurelia-event-aggregator';

/**
 * ${2:}
 */
@inject(EventAggregator)
export class ${1:ViewModel} {

    // @bindable prop = null;

    /**
     * 构造函数
     */
    constructor(eventAggregator) {
        this.eventAggregator = eventAggregator;

        // this.subscribe1 = this.eventAggregator.subscribe('event_xxx', (payload) => {
        //  
        // });

    }

    /**
     * 在视图和视图模型都被创建后调用, 允许访问视图实例对象.
     * @param  {[object]} owningView: This is the view that the component is declared inside of.
     * @param  {[object]} myView: If the component itself has a view.
     */
    created(owningView, myView) {

    }

    /**
     * 当数据绑定引擎绑定到视图时被调用
     * @param  {[object]} bindingCtx: The "binding context" to which the component is being bound will be passed first.
     * @param  {[object]} overrideCtx: The override context contains information used to traverse the parent hierarchy and can also be used to add any contextual properties that the component wants to add.
     */
    bind(bindingCtx, overrideCtx) {

    }

    /**
     * 当数据绑定引擎从视图解除绑定时被调用
     */
    unbind() {
        // this.subscribe1.dispose();
    }

    /**
     * 当视图被附加到DOM中时被调用
     */
    attached() {

    }

    /**
     * 当视图从DOM中分离时被调用
     */
    detached() {

    }

    /**
     * 在视图模型(ViewModel)展示前执行一些自定义代码逻辑
     * @param  {[object]} params                参数
     * @param  {[object]} routeConfig           路由配置
     * @param  {[object]} navigationInstruction 导航指令
     * @return {[promise]}                      你可以可选的返回一个延迟许诺(promise), 告诉路由等待执行bind和attach视图(view), 直到你完成你的处理工作.
     */
    activate(params, routeConfig, navigationInstruction) {

    }
}

]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>au-view-model</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
    <scope>source.js</scope>
</snippet>